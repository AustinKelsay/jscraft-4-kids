<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My First Person JSCraft Game</title>
  <style>
    /* This CSS makes our game fullscreen */
    body {
      margin: 0;
      /* Remove all white space */
      padding: 0;
      /* Remove all padding */
      background-color: #000;
      /* Black background */
      font-family: Arial, sans-serif;
      /* Choose a clean font */
      overflow: hidden;
      /* Hide scrollbars for fullscreen effect */
    }

    #gameCanvas {
      display: block;
      /* Make the canvas a block element */
      background-color: #87CEEB;
      /* Sky blue background */
      cursor: crosshair;
      /* Show crosshair cursor like in games */
    }

    #instructions {
      position: absolute;
      /* Position over the game */
      top: 10px;
      /* Distance from top */
      left: 10px;
      /* Distance from left */
      color: #FFD700;
      /* Gold text */
      font-size: 14px;
      /* Smaller text for overlay */
      background-color: rgba(0, 0, 0, 0.7);
      /* Semi-transparent black background */
      padding: 10px;
      /* Space inside the instruction box */
      border-radius: 5px;
      /* Rounded corners */
      z-index: 10;
      /* Make sure it appears above the canvas */
      max-width: 300px;
      /* Don't let it get too wide */
    }
  </style>
</head>

<body>
  <!-- This is where our fullscreen game will appear -->
  <canvas id="gameCanvas"></canvas>

  <div id="instructions">
    <strong>ðŸŽ® First Person Adventure</strong><br>
    WASD or arrows to move<br>
    Q/E to turn left/right<br>
    Press F11 for true fullscreen!
  </div>

  <script>
    // Get the canvas element from our HTML (this is where we draw our game)
    const canvas = document.getElementById('gameCanvas');

    // Get the "context" - this lets us draw on the canvas
    const ctx = canvas.getContext('2d');

    // Make the canvas fill the entire screen
    function resizeCanvas() {
      canvas.width = window.innerWidth;   // Full screen width
      canvas.height = window.innerHeight; // Full screen height
    }

    // Resize canvas when page loads and when window is resized
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Create our player - this represents where we are and where we're looking
    const player = {
      x: 400,        // Our position in the world (left-right)
      y: 300,        // Our position in the world (forward-back)
      angle: 0,      // Which direction we're facing (in radians)
      speed: 3,      // How fast we walk
      turnSpeed: 0.05 // How fast we turn
    };

    // Keep track of which keys are being pressed
    const keys = {
      left: false,   // A key or left arrow (strafe left)
      right: false,  // D key or right arrow (strafe right)
      up: false,     // W key or up arrow (walk forward)
      down: false,   // S key or down arrow (walk backward)
      turnLeft: false,  // Turn left
      turnRight: false  // Turn right
    };

    // Create objects in our 3D world - these have positions and will be drawn with perspective
    const worldObjects = [
      // Trees - tall objects that look like trees from first person
      {x: 200, y: 100, width: 40, height: 120, color: '#228B22', type: 'tree'},
      {x: 500, y: 200, width: 40, height: 120, color: '#228B22', type: 'tree'},
      {x: 150, y: 400, width: 40, height: 120, color: '#0F5F0F', type: 'tree'},
      {x: 600, y: 350, width: 40, height: 120, color: '#228B22', type: 'tree'},
      {x: 300, y: 500, width: 40, height: 120, color: '#0F5F0F', type: 'tree'},
      {x: 700, y: 150, width: 40, height: 120, color: '#228B22', type: 'tree'},

      // Rocks - smaller ground objects
      {x: 350, y: 250, width: 30, height: 25, color: '#696969', type: 'rock'},
      {x: 180, y: 300, width: 25, height: 20, color: '#808080', type: 'rock'},
      {x: 550, y: 400, width: 35, height: 30, color: '#696969', type: 'rock'},
      {x: 250, y: 200, width: 28, height: 22, color: '#808080', type: 'rock'},

      // Houses - rectangular buildings
      {x: 100, y: 200, width: 80, height: 100, color: '#D2691E', type: 'house'},
      {x: 650, y: 300, width: 80, height: 100, color: '#CD853F', type: 'house'}
    ];

    // This function draws the sky and ground
    function drawBackground() {
      // Draw sky (top half of screen)
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / 2);
      gradient.addColorStop(0, '#87CEEB'); // Light blue at top
      gradient.addColorStop(1, '#E0F6FF'); // Lighter blue at horizon
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height / 2);

      // Draw ground (bottom half of screen) 
      const groundGradient = ctx.createLinearGradient(0, canvas.height / 2, 0, canvas.height);
      groundGradient.addColorStop(0, '#90EE90'); // Light green at horizon
      groundGradient.addColorStop(1, '#228B22'); // Darker green at bottom
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
    }

    // This function calculates distance between two points
    function getDistance(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // This function calculates the angle from player to an object
    function getAngleToObject(objX, objY) {
      const dx = objX - player.x;
      const dy = objY - player.y;
      return Math.atan2(dy, dx);
    }

    // This function draws objects with 3D perspective
    function drawWorldObjects() {
      // Sort objects by distance (far objects drawn first, near objects drawn last)
      const sortedObjects = worldObjects.slice().sort((a, b) => {
        const distA = getDistance(player.x, player.y, a.x, a.y);
        const distB = getDistance(player.x, player.y, b.x, b.y);
        return distB - distA; // Sort far to near
      });

      sortedObjects.forEach(obj => {
        // Calculate distance from player to object
        const distance = getDistance(player.x, player.y, obj.x, obj.y);

        // Don't draw objects that are too far away
        if (distance > 400) return;

        // Calculate angle from player to object
        const angleToObject = getAngleToObject(obj.x, obj.y);

        // Calculate relative angle (difference between where we're looking and where object is)
        let relativeAngle = angleToObject - player.angle;

        // Normalize angle to be between -PI and PI
        while (relativeAngle > Math.PI) relativeAngle -= 2 * Math.PI;
        while (relativeAngle < -Math.PI) relativeAngle += 2 * Math.PI;

        // Only draw objects that are in front of us (within our field of view)
        const fieldOfView = Math.PI / 3; // 60 degrees field of view
        if (Math.abs(relativeAngle) > fieldOfView) return;

        // Calculate screen position based on angle (using current screen width)
        const screenCenterX = canvas.width / 2;
        const screenX = screenCenterX + (relativeAngle / fieldOfView) * (canvas.width / 2);

        // Calculate object size based on distance (closer = bigger)
        const baseSize = 200; // Base size for objects
        const scale = baseSize / distance;
        const screenWidth = obj.width * scale;
        const screenHeight = obj.height * scale;

        // Calculate vertical position (objects sit on the ground)
        const horizon = canvas.height / 2;
        const screenY = horizon - screenHeight;

        // Only draw if object is visible on screen
        if (screenX + screenWidth > 0 && screenX < canvas.width && screenY < canvas.height) {
          // Set object color (make distant objects slightly darker)
          const brightness = Math.max(0.3, 1 - distance / 400);
          const color = obj.color;

          // Parse hex color and apply brightness
          const r = parseInt(color.substr(1, 2), 16);
          const g = parseInt(color.substr(3, 2), 16);
          const b = parseInt(color.substr(5, 2), 16);

          const adjustedColor = `rgb(${Math.floor(r * brightness)}, ${Math.floor(g * brightness)}, ${Math.floor(b * brightness)})`;
          ctx.fillStyle = adjustedColor;

          // Draw the object
          ctx.fillRect(screenX, screenY, screenWidth, screenHeight);

          // Add details based on object type
          if (obj.type === 'tree' && screenWidth > 10) {
            // Add tree trunk (brown base)
            ctx.fillStyle = `rgb(${Math.floor(139 * brightness)}, ${Math.floor(69 * brightness)}, ${Math.floor(19 * brightness)})`;
            const trunkWidth = screenWidth * 0.3;
            const trunkHeight = screenHeight * 0.3;
            ctx.fillRect(screenX + screenWidth / 2 - trunkWidth / 2, screenY + screenHeight - trunkHeight, trunkWidth, trunkHeight);
          } else if (obj.type === 'house' && screenWidth > 15) {
            // Add house roof (triangular top)
            ctx.fillStyle = `rgb(${Math.floor(160 * brightness)}, ${Math.floor(82 * brightness)}, ${Math.floor(45 * brightness)})`;
            ctx.beginPath();
            ctx.moveTo(screenX, screenY);
            ctx.lineTo(screenX + screenWidth / 2, screenY - screenHeight * 0.3);
            ctx.lineTo(screenX + screenWidth, screenY);
            ctx.closePath();
            ctx.fill();

            // Add door
            if (screenWidth > 25) {
              ctx.fillStyle = `rgb(${Math.floor(101 * brightness)}, ${Math.floor(67 * brightness)}, ${Math.floor(33 * brightness)})`;
              const doorWidth = screenWidth * 0.25;
              const doorHeight = screenHeight * 0.6;
              ctx.fillRect(screenX + screenWidth / 2 - doorWidth / 2, screenY + screenHeight - doorHeight, doorWidth, doorHeight);
            }
          }
        }
      });
    }

    // This function draws a crosshair in the center of the screen
    function drawCrosshair() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      ctx.strokeStyle = '#FFFFFF'; // White color
      ctx.lineWidth = 2;

      // Draw horizontal line
      ctx.beginPath();
      ctx.moveTo(centerX - 10, centerY);
      ctx.lineTo(centerX + 10, centerY);
      ctx.stroke();

      // Draw vertical line  
      ctx.beginPath();
      ctx.moveTo(centerX, centerY - 10);
      ctx.lineTo(centerX, centerY + 10);
      ctx.stroke();
    }

    // This function shows our compass direction
    function drawCompass() {
      const compassX = 80;  // Moved further from edge for fullscreen
      const compassY = 80;  // Moved further from edge for fullscreen
      const compassRadius = 40;

      // Draw compass background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.beginPath();
      ctx.arc(compassX, compassY, compassRadius, 0, 2 * Math.PI);
      ctx.fill();

      // Draw compass needle pointing north
      ctx.strokeStyle = '#FF0000'; // Red for north
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(compassX, compassY);
      const needleLength = 25;
      const needleX = compassX + Math.cos(-player.angle - Math.PI / 2) * needleLength;
      const needleY = compassY + Math.sin(-player.angle - Math.PI / 2) * needleLength;
      ctx.lineTo(needleX, needleY);
      ctx.stroke();

      // Add compass label
      ctx.fillStyle = '#FFFFFF';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('N', compassX, compassY - compassRadius - 10);
    }

    // This function updates our player position and rotation
    function updatePlayer() {
      // Handle turning
      if (keys.turnLeft) {
        player.angle -= player.turnSpeed;
      }
      if (keys.turnRight) {
        player.angle += player.turnSpeed;
      }

      // Handle movement based on current facing direction
      if (keys.up) {
        // Move forward in the direction we're facing
        player.x += Math.cos(player.angle) * player.speed;
        player.y += Math.sin(player.angle) * player.speed;
      }
      if (keys.down) {
        // Move backward (opposite to facing direction)
        player.x -= Math.cos(player.angle) * player.speed;
        player.y -= Math.sin(player.angle) * player.speed;
      }
      if (keys.left) {
        // Strafe left (perpendicular to facing direction)
        player.x += Math.cos(player.angle - Math.PI / 2) * player.speed;
        player.y += Math.sin(player.angle - Math.PI / 2) * player.speed;
      }
      if (keys.right) {
        // Strafe right (perpendicular to facing direction)
        player.x += Math.cos(player.angle + Math.PI / 2) * player.speed;
        player.y += Math.sin(player.angle + Math.PI / 2) * player.speed;
      }

      // Keep player within world bounds (expanded for larger world)
      player.x = Math.max(50, Math.min(1200, player.x));
      player.y = Math.max(50, Math.min(800, player.y));
    }

    // This is our main game loop - it runs over and over to create animation
    function gameLoop() {
      // Step 1: Update player position and rotation
      updatePlayer();

      // Step 2: Draw the background (sky and ground)
      drawBackground();

      // Step 3: Draw all world objects with 3D perspective
      drawWorldObjects();

      // Step 4: Draw UI elements (crosshair and compass)
      drawCrosshair();
      drawCompass();

      // Step 5: Request the next frame (this makes the loop keep going)
      requestAnimationFrame(gameLoop);
    }

    // Listen for when keys are pressed down
    document.addEventListener('keydown', function (event) {
      // Check which key was pressed and update our keys object
      switch (event.key.toLowerCase()) {
        case 'arrowleft':
        case 'a':
          keys.left = true;
          break;
        case 'arrowright':
        case 'd':
          keys.right = true;
          break;
        case 'arrowup':
        case 'w':
          keys.up = true;
          break;
        case 'arrowdown':
        case 's':
          keys.down = true;
          break;
        case 'q':
          keys.turnLeft = true;
          break;
        case 'e':
          keys.turnRight = true;
          break;
      }
    });

    // Listen for when keys are released (let go)
    document.addEventListener('keyup', function (event) {
      // Check which key was released and update our keys object
      switch (event.key.toLowerCase()) {
        case 'arrowleft':
        case 'a':
          keys.left = false;
          break;
        case 'arrowright':
        case 'd':
          keys.right = false;
          break;
        case 'arrowup':
        case 'w':
          keys.up = false;
          break;
        case 'arrowdown':
        case 's':
          keys.down = false;
          break;
        case 'q':
          keys.turnLeft = false;
          break;
        case 'e':
          keys.turnRight = false;
          break;
      }
    });

    // Start the game! This begins our game loop
    gameLoop();

        // Congratulations! You now have a true first-person 3D exploration game!
        // Here are some ideas for what you could add next:
        // 1. Add collision detection so you can't walk through objects
        // 2. Add more object types (cars, street lamps, benches)
        // 3. Create a larger world with more objects to explore
        // 4. Add sound effects for footsteps and ambient sounds
        // 5. Add a flashlight effect for nighttime exploration
        // 6. Create different environments (city, forest, beach)
        // 7. Add animated objects (spinning windmills, moving cars)
        // 8. Include a quest system with objectives
        // 9. Add weather effects that affect visibility
        // 10. Create multiplayer support to explore with friends
  </script>
</body>

</html>