<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VoxelCraft - Build & Dig!</title>
  <style>
    /* This CSS makes our voxel game fullscreen */
    body {
      margin: 0;
      /* Remove all white space */
      padding: 0;
      /* Remove all padding */
      background-color: #000;
      /* Black background */
      font-family: Arial, sans-serif;
      /* Choose a clean font */
      overflow: hidden;
      /* Hide scrollbars for fullscreen effect */
    }

    #gameCanvas {
      display: block;
      /* Make the canvas a block element */
      background-color: #87CEEB;
      /* Sky blue background */
      cursor: crosshair;
      /* Show crosshair cursor like in games */
    }

    #instructions {
      position: absolute;
      /* Position over the game */
      top: 10px;
      /* Distance from top */
      left: 10px;
      /* Distance from left */
      color: #FFD700;
      /* Gold text */
      font-size: 14px;
      /* Smaller text for overlay */
      background-color: rgba(0, 0, 0, 0.8);
      /* Semi-transparent black background */
      padding: 15px;
      /* Space inside the instruction box */
      border-radius: 8px;
      /* Rounded corners */
      z-index: 10;
      /* Make sure it appears above the canvas */
      max-width: 250px;
      /* Don't let it get too wide */
      line-height: 1.4;
      /* Better line spacing */
    }

    #hotbar {
      position: absolute;
      /* Position over the game */
      bottom: 20px;
      /* Distance from bottom */
      left: 50%;
      /* Center horizontally */
      transform: translateX(-50%);
      /* Perfect centering */
      background-color: rgba(0, 0, 0, 0.8);
      /* Semi-transparent black */
      padding: 10px;
      /* Space inside */
      border-radius: 8px;
      /* Rounded corners */
      display: flex;
      /* Arrange items horizontally */
      gap: 10px;
      /* Space between items */
    }

    .hotbar-slot {
      width: 50px;
      /* Square slots */
      height: 50px;
      /* Square slots */
      border: 2px solid #666;
      /* Gray border */
      border-radius: 4px;
      /* Slightly rounded */
      display: flex;
      /* Center content */
      align-items: center;
      /* Center vertically */
      justify-content: center;
      /* Center horizontally */
      font-size: 12px;
      /* Text size */
      color: white;
      /* White text */
      cursor: pointer;
      /* Show it's clickable */
    }

    .hotbar-slot.selected {
      border-color: #FFD700;
      /* Gold border when selected */
      background-color: rgba(255, 215, 0, 0.2);
      /* Slight gold tint */
    }
  </style>
</head>

<body>
  <!-- This is where our fullscreen voxel game will appear -->
  <canvas id="gameCanvas"></canvas>

  <div id="instructions">
    <strong>üß± VoxelCraft Builder!</strong><br>
    <strong>Move:</strong> WASD or arrows<br>
    <strong>Look:</strong> Q/E to turn<br>
    <strong>Build:</strong> B key or Right click<br>
    <strong>Dig:</strong> Spacebar or Left click<br>
    <strong>Blocks:</strong> 1-5 keys<br>
    <em>Aim at blocks to modify them!</em>
  </div>

  <!-- Hotbar for selecting block types -->
  <div id="hotbar">
    <div class="hotbar-slot selected" data-block="grass" style="background-color: #90EE90;">üå±</div>
    <div class="hotbar-slot" data-block="stone" style="background-color: #808080;">ü™®</div>
    <div class="hotbar-slot" data-block="wood" style="background-color: #8B4513;">ü™µ</div>
    <div class="hotbar-slot" data-block="sand" style="background-color: #F4E4BC;">üèñÔ∏è</div>
    <div class="hotbar-slot" data-block="water" style="background-color: #4169E1;">üíß</div>
  </div>

  <script>
    // Get the canvas element from our HTML
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Make the canvas fill the entire screen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Voxel world settings
    const CHUNK_SIZE = 32; // Size of each chunk (32x32 blocks)
    const BLOCK_SIZE = 16; // Size of each block in world units
    const RENDER_DISTANCE = 200; // How far we can see blocks

    // Block types - each has different properties
    const BLOCK_TYPES = {
      air: {color: null, solid: false, name: 'Air'},
      grass: {color: '#90EE90', solid: true, name: 'Grass'},
      stone: {color: '#808080', solid: true, name: 'Stone'},
      wood: {color: '#8B4513', solid: true, name: 'Wood'},
      sand: {color: '#F4E4BC', solid: true, name: 'Sand'},
      water: {color: '#4169E1', solid: false, name: 'Water'}
    };

    // Create our player
    const player = {
      x: 400,        // Position in world
      y: 300,
      z: 50,         // Height above ground (for 3D effect)
      angle: 0,      // Which direction we're facing
      speed: 4,      // Movement speed
      turnSpeed: 0.05, // Turn speed
      selectedBlock: 'grass' // Currently selected block type
    };

    // Track pressed keys
    const keys = {
      left: false, right: false, up: false, down: false,
      turnLeft: false, turnRight: false,
      build: false, destroy: false  // New keys for building and destroying
    };

    // Mouse tracking for building/digging
    let mouseDown = false;
    let rightMouseDown = false;

    // Create our voxel world - this is a 3D grid of blocks
    const world = {};

    // Helper function to get world coordinates from grid position
    function getWorldPos(gridX, gridY, gridZ) {
      return {
        x: gridX * BLOCK_SIZE,
        y: gridY * BLOCK_SIZE,
        z: gridZ * BLOCK_SIZE
      };
    }

    // Helper function to get grid position from world coordinates
    function getGridPos(worldX, worldY, worldZ) {
      return {
        x: Math.floor(worldX / BLOCK_SIZE),
        y: Math.floor(worldY / BLOCK_SIZE),
        z: Math.floor(worldZ / BLOCK_SIZE)
      };
    }

    // Get block at specific grid position
    function getBlock(x, y, z) {
      const key = `${x},${y},${z}`;
      return world[key] || 'air';
    }

    // Set block at specific grid position
    function setBlock(x, y, z, blockType) {
      const key = `${x},${y},${z}`;
      if (blockType === 'air') {
        delete world[key]; // Remove air blocks to save memory
      } else {
        world[key] = blockType;
      }
    }

    // Generate initial terrain
    function generateTerrain() {
      // Create a simple terrain with hills
      for (let x = -20; x < 20; x++) {
        for (let y = -20; y < 20; y++) {
          // Create hills using sine waves
          const height = Math.floor(3 + 2 * Math.sin(x * 0.1) * Math.cos(y * 0.1));

          // Place blocks from ground up to height
          for (let z = 0; z <= height; z++) {
            if (z === height) {
              setBlock(x, y, z, 'grass'); // Top layer is grass
            } else if (z >= height - 2) {
              setBlock(x, y, z, 'stone'); // Stone beneath grass
            } else {
              setBlock(x, y, z, 'stone'); // Deep stone
            }
          }

          // Add some random trees
          if (Math.random() < 0.05 && height > 2) {
            const treeHeight = 3 + Math.floor(Math.random() * 3);
            for (let treeZ = height + 1; treeZ <= height + treeHeight; treeZ++) {
              setBlock(x, y, treeZ, 'wood');
            }
            // Add leaves around the top
            for (let dx = -1; dx <= 1; dx++) {
              for (let dy = -1; dy <= 1; dy++) {
                if (Math.random() < 0.7) {
                  setBlock(x + dx, y + dy, height + treeHeight, 'grass');
                }
              }
            }
          }
        }
      }
    }

    // Draw the sky and ground
    function drawBackground() {
      // Sky gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / 2);
      gradient.addColorStop(0, '#87CEEB');
      gradient.addColorStop(1, '#E0F6FF');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height / 2);

      // Ground
      const groundGradient = ctx.createLinearGradient(0, canvas.height / 2, 0, canvas.height);
      groundGradient.addColorStop(0, '#8FBC8F');
      groundGradient.addColorStop(1, '#556B2F');
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
    }

    // Calculate distance between two points
    function getDistance(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Get angle from player to a position
    function getAngleToPosition(x, y) {
      const dx = x - player.x;
      const dy = y - player.y;
      return Math.atan2(dy, dx);
    }

    // Draw all visible voxels with 3D perspective
    function drawVoxels() {
      const visibleBlocks = [];

      // Find all blocks within render distance
      const playerGridPos = getGridPos(player.x, player.y, player.z);
      const searchRadius = Math.ceil(RENDER_DISTANCE / BLOCK_SIZE);

      for (let x = playerGridPos.x - searchRadius; x <= playerGridPos.x + searchRadius; x++) {
        for (let y = playerGridPos.y - searchRadius; y <= playerGridPos.y + searchRadius; y++) {
          for (let z = 0; z <= 10; z++) { // Only check up to height 10
            const blockType = getBlock(x, y, z);
            if (blockType !== 'air') {
              const worldPos = getWorldPos(x, y, z);
              const distance = getDistance(player.x, player.y, worldPos.x, worldPos.y);

              if (distance <= RENDER_DISTANCE) {
                visibleBlocks.push({
                  gridPos: {x, y, z},
                  worldPos,
                  blockType,
                  distance
                });
              }
            }
          }
        }
      }

      // Sort blocks by distance (far to near for proper rendering)
      visibleBlocks.sort((a, b) => b.distance - a.distance);

      // Draw each visible block
      visibleBlocks.forEach(block => {
        drawVoxel(block.worldPos, block.blockType, block.distance, block.gridPos);
      });
    }

    // Draw a single voxel (3D block)
    function drawVoxel(worldPos, blockType, distance, gridPos) {
      const blockInfo = BLOCK_TYPES[blockType];
      if (!blockInfo || !blockInfo.color) return;

      // Calculate angle from player to block
      const angleToBlock = getAngleToPosition(worldPos.x, worldPos.y);
      let relativeAngle = angleToBlock - player.angle;

      // Normalize angle
      while (relativeAngle > Math.PI) relativeAngle -= 2 * Math.PI;
      while (relativeAngle < -Math.PI) relativeAngle += 2 * Math.PI;

      // Check if block is in field of view
      const fieldOfView = Math.PI / 2.5; // About 72 degrees
      if (Math.abs(relativeAngle) > fieldOfView) return;

      // Calculate screen position
      const screenCenterX = canvas.width / 2;
      const screenX = screenCenterX + (relativeAngle / fieldOfView) * (canvas.width / 2);

      // Calculate size based on distance
      const baseSize = 400;
      const scale = baseSize / distance;
      const screenWidth = BLOCK_SIZE * scale;
      const screenHeight = BLOCK_SIZE * scale;

      // Calculate vertical position based on height
      const horizon = canvas.height / 2;
      const heightOffset = (worldPos.z - player.z) * scale * 0.5;
      const screenY = horizon - screenHeight - heightOffset;

      // Only draw if visible on screen
      if (screenX + screenWidth > 0 && screenX < canvas.width &&
        screenY + screenHeight > 0 && screenY < canvas.height && screenWidth > 1) {

        // Apply distance fog
        const brightness = Math.max(0.3, 1 - distance / RENDER_DISTANCE);
        const color = blockInfo.color;

        // Parse and adjust color
        const r = parseInt(color.substr(1, 2), 16);
        const g = parseInt(color.substr(3, 2), 16);
        const b = parseInt(color.substr(5, 2), 16);

        const adjustedColor = `rgb(${Math.floor(r * brightness)}, ${Math.floor(g * brightness)}, ${Math.floor(b * brightness)})`;

        // Draw the main block face
        ctx.fillStyle = adjustedColor;
        ctx.fillRect(screenX, screenY, screenWidth, screenHeight);

        // Add 3D effect with slightly darker edges
        ctx.fillStyle = `rgb(${Math.floor(r * brightness * 0.8)}, ${Math.floor(g * brightness * 0.8)}, ${Math.floor(b * brightness * 0.8)})`;
        ctx.fillRect(screenX, screenY, screenWidth, 2); // Top edge
        ctx.fillRect(screenX, screenY, 2, screenHeight); // Left edge

        // Store block info for click detection
        if (screenWidth > 10) { // Only make larger blocks clickable
          const blockData = {
            screenX, screenY, screenWidth, screenHeight,
            gridPos, blockType, distance
          };

          // Store in global array for click detection
          if (!window.clickableBlocks) window.clickableBlocks = [];
          window.clickableBlocks.push(blockData);
        }
      }
    }

    // Draw crosshair
    function drawCrosshair() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(centerX - 15, centerY);
      ctx.lineTo(centerX + 15, centerY);
      ctx.moveTo(centerX, centerY - 15);
      ctx.lineTo(centerX, centerY + 15);
      ctx.stroke();
    }

    // Update player movement
    function updatePlayer() {
      if (keys.turnLeft) player.angle -= player.turnSpeed;
      if (keys.turnRight) player.angle += player.turnSpeed;

      if (keys.up) {
        player.x += Math.cos(player.angle) * player.speed;
        player.y += Math.sin(player.angle) * player.speed;
      }
      if (keys.down) {
        player.x -= Math.cos(player.angle) * player.speed;
        player.y -= Math.sin(player.angle) * player.speed;
      }
      if (keys.left) {
        player.x += Math.cos(player.angle - Math.PI / 2) * player.speed;
        player.y += Math.sin(player.angle - Math.PI / 2) * player.speed;
      }
      if (keys.right) {
        player.x += Math.cos(player.angle + Math.PI / 2) * player.speed;
        player.y += Math.sin(player.angle + Math.PI / 2) * player.speed;
      }
    }

    // Function to build a block at target location
    function buildBlock() {
      const targetBlock = getTargetBlock();
      if (targetBlock) {
        // Place block above the target block
        setBlock(targetBlock.gridPos.x, targetBlock.gridPos.y, targetBlock.gridPos.z + 1, player.selectedBlock);
      }
    }

    // Function to destroy/dig a block at target location
    function destroyBlock() {
      const targetBlock = getTargetBlock();
      if (targetBlock) {
        setBlock(targetBlock.gridPos.x, targetBlock.gridPos.y, targetBlock.gridPos.z, 'air');
      }
    }
    function getTargetBlock() {
      if (!window.clickableBlocks) return null;

      // Find the closest block to the center of the screen
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      let closestBlock = null;
      let closestDistance = Infinity;

      window.clickableBlocks.forEach(block => {
        const blockCenterX = block.screenX + block.screenWidth / 2;
        const blockCenterY = block.screenY + block.screenHeight / 2;
        const distance = Math.sqrt(
          Math.pow(blockCenterX - centerX, 2) +
          Math.pow(blockCenterY - centerY, 2)
        );

        if (distance < closestDistance && distance < 100) {
          closestDistance = distance;
          closestBlock = block;
        }
      });

      return closestBlock;
    }

    // Main game loop
    function gameLoop() {
      // Clear clickable blocks array
      window.clickableBlocks = [];

      updatePlayer();

      // Handle continuous building/destroying when keys are held
      if (keys.build) buildBlock();
      if (keys.destroy) destroyBlock();

      drawBackground();
      drawVoxels();
      drawCrosshair();

      requestAnimationFrame(gameLoop);
    }

    // Keyboard controls
    document.addEventListener('keydown', function (event) {
      switch (event.key.toLowerCase()) {
        case 'a': case 'arrowleft': keys.left = true; break;
        case 'd': case 'arrowright': keys.right = true; break;
        case 'w': case 'arrowup': keys.up = true; break;
        case 's': case 'arrowdown': keys.down = true; break;
        case 'q': keys.turnLeft = true; break;
        case 'e': keys.turnRight = true; break;

        // Building and destroying controls
        case 'b': keys.build = true; break;          // B key to build
        case ' ': keys.destroy = true; break;        // Spacebar to destroy

        // Block selection hotkeys
        case '1': selectBlock('grass'); break;
        case '2': selectBlock('stone'); break;
        case '3': selectBlock('wood'); break;
        case '4': selectBlock('sand'); break;
        case '5': selectBlock('water'); break;
      }
    });

    document.addEventListener('keyup', function (event) {
      switch (event.key.toLowerCase()) {
        case 'a': case 'arrowleft': keys.left = false; break;
        case 'd': case 'arrowright': keys.right = false; break;
        case 'w': case 'arrowup': keys.up = false; break;
        case 's': case 'arrowdown': keys.down = false; break;
        case 'q': keys.turnLeft = false; break;
        case 'e': keys.turnRight = false; break;

        // Building and destroying controls
        case 'b': keys.build = false; break;         // Release B key
        case ' ': keys.destroy = false; break;      // Release spacebar
      }
    });

    // Mouse controls for building/digging (alternative to keyboard)
    canvas.addEventListener('mousedown', function (event) {
      event.preventDefault();

      if (event.button === 0) { // Left click - dig/break blocks (same as spacebar)
        destroyBlock();
      } else if (event.button === 2) { // Right click - place blocks (same as B key)
        buildBlock();
      }
    });

    // Prevent right-click context menu
    canvas.addEventListener('contextmenu', function (event) {
      event.preventDefault();
    });

    // Hotbar selection
    function selectBlock(blockType) {
      player.selectedBlock = blockType;

      // Update hotbar UI
      document.querySelectorAll('.hotbar-slot').forEach(slot => {
        slot.classList.remove('selected');
      });
      document.querySelector(`[data-block="${blockType}"]`).classList.add('selected');
    }

    // Hotbar click handlers
    document.querySelectorAll('.hotbar-slot').forEach(slot => {
      slot.addEventListener('click', function () {
        selectBlock(this.dataset.block);
      });
    });

    // Initialize the game
    generateTerrain();
    gameLoop();

        // Congratulations! You now have a true voxel-based world!
        // Here are some ideas for what you could add next:
        // 1. Different block types with special properties
        // 2. Inventory system to collect broken blocks
        // 3. Crafting system to combine blocks
        // 4. Multiplayer support for building together
        // 5. Save/load world functionality
        // 6. Lighting system with torches
        // 7. Water physics and flowing
        // 8. Mob spawning and AI
        // 9. Underground cave generation
        // 10. Redstone-like logic blocks
  </script>
</body>

</html>